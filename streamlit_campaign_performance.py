# -*- coding: utf-8 -*-
"""streamlit campaign performance.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SgRIXaFxZnDn9o_6XvhRFQGt0kfiwi7R
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# --- 1. Cleaning & imputation ---
def clean_and_impute(df,
                     date_col='Date',
                     month_col='Month',
                     value_col='Value',
                     carpet_col='Carpet Area',
                     store_open_col='Store Open Date',
                     brand_col='Brand Name'):
    df = df.copy()
    df = df.rename(columns={value_col: 'sales'})
    df[date_col] = pd.to_datetime(df[date_col], errors='coerce')
    df['month_parsed'] = pd.to_datetime(
        df[month_col].astype(str).str.replace("'", "").str.strip(),
        format='%b%y',
        errors='coerce'
    )
    if store_open_col in df.columns:
        df[store_open_col] = pd.to_datetime(df[store_open_col], errors='coerce')

    def clean_numeric(s):
        return pd.to_numeric(
            s.astype(str).str.replace(r'[^0-9\.\-]', '', regex=True),
            errors='coerce'
        )
    df['sales'] = clean_numeric(df['sales'])
    df[carpet_col] = clean_numeric(df[carpet_col])

    brand_missing = df.groupby(brand_col)['sales'].apply(lambda x: x.isna().mean())
    keep_brands = brand_missing[brand_missing <= 0.3].index
    dropped_brands = brand_missing[brand_missing > 0.3]
    df = df[df[brand_col].isin(keep_brands)]

    if store_open_col in df.columns:
        mask = df[store_open_col].notna() & df[date_col].notna() & (df[date_col] < df[store_open_col])
        df.loc[mask, 'sales'] = 0.0

    def impute_brand(g):
        g = g.sort_values(date_col).set_index(date_col)
        s = g['sales']
        s_interp = s.interpolate(method='time', limit_direction='both')
        s_filled = s_interp.fillna(s.median()).fillna(0)
        g['sales_imputed'] = s_filled
        g['imputed_flag'] = s.isna() & g['sales_imputed'].notna()
        return g.reset_index()

    df = df.groupby(brand_col, group_keys=False).apply(impute_brand).reset_index(drop=True)

    diag = {
        'rows': len(df),
        'brands_dropped': int(len(dropped_brands)),
        'remaining_brands': int(len(keep_brands)),
        'missing_after_imputation': int(df['sales_imputed'].isna().sum()),
        'total_imputed': int(df['imputed_flag'].sum())
    }
    return df, diag, dropped_brands

# --- 2. Expected sales & metrics ---
def compute_expected_parallel(df, target, controls, pre_start, measure_start, measure_end):
    target_df = df[df['Brand Name'] == target].set_index('Date').sort_index()
    control_df = df[df['Brand Name'].isin(controls)].pivot(index='Date', columns='Brand Name', values='sales_imputed').fillna(0)

    # Check data availability
    if target_df.loc[pre_start:measure_end].empty or control_df.loc[pre_start:measure_end].empty:
        raise ValueError(f"Data unavailable for target '{target}' or controls in the requested period")

    pre_target_sum = target_df.loc[pre_start:measure_start]['sales_imputed'].sum()
    pre_control_sum = control_df.loc[pre_start:measure_start].sum(axis=1).sum()
    if pre_control_sum == 0:
        raise ValueError(f"Data unavailable: control sum in pre-period is zero for target '{target}'")

    scale = pre_target_sum / pre_control_sum
    control_meas_sum = control_df.loc[measure_start:measure_end].sum(axis=1)
    expected_series = control_meas_sum * scale
    target_series = target_df.loc[measure_start:measure_end]['sales_imputed']

    incr_sales = target_series.sum() - expected_series.sum()
    lift_pct = (target_series.sum() - expected_series.sum()) / expected_series.sum() * 100
    roi = incr_sales / 1  # Placeholder, actual spend provided outside
    return target_series, expected_series, control_meas_sum, incr_sales, lift_pct

def compute_roi(incr_sales, spend):
    return incr_sales / spend if spend != 0 else np.nan

# --- 3. HTML report helper ---
def save_html_report(campaign_name, target_dict, expected_dict, control_dict, incremental_dict, lift_dict, roi_targets_dict, roi_total, campaign_start, campaign_end):
    fig, axs = plt.subplots(len(target_dict)+1,1, figsize=(10,4*(len(target_dict)+1)), sharex=True)
    if len(target_dict) == 1:
        axs = [axs]

    # 1. Total
    total_actual = sum([v for v in target_dict.values()])
    total_expected = sum([v for v in expected_dict.values()])
    total_control = control_dict.sum(axis=1)
    axs[0].plot(total_actual.index, total_actual.values, label="Total Actual")
    axs[0].plot(total_expected.index, total_expected.values, label="Total Expected")
    axs[0].plot(total_control.index, total_control.values, label="Sum Controls")
    axs[0].axvspan(campaign_start, campaign_end, color='yellow', alpha=0.2, label="Campaign Period")
    axs[0].legend()
    axs[0].set_title("Total Sales")

    # 2. Individual targets
    for i, t in enumerate(target_dict.keys(),1):
        axs[i].plot(target_dict[t].index, target_dict[t].values, label=f"{t} Actual")
        axs[i].plot(expected_dict[t].index, expected_dict[t].values, label=f"{t} Expected")
        axs[i].plot(control_dict.sum(axis=1).index, control_dict.sum(axis=1).values, label="Sum Controls")
        axs[i].axvspan(campaign_start, campaign_end, color='yellow', alpha=0.2)
        axs[i].legend(title=f"Lift: {lift_dict[t]:.1f}%, ROI: {roi_targets_dict[t]:.2f}")
        axs[i].set_title(f"Target Brand: {t}")

    plt.tight_layout()
    html_bytes = BytesIO()
    fig.savefig(html_bytes, format='html', bbox_inches='tight')
    plt.close(fig)
    html_bytes.seek(0)
    with open(f"{campaign_name.replace(' ','_')}_report.html", "wb") as f:
        f.write(html_bytes.read())

# --- 4. Streamlit App ---
st.title("Mall Campaign Incrementality Analysis")

uploaded_file = st.file_uploader("Upload raw sales CSV", type=["csv"])
if uploaded_file is not None:
    df_raw = pd.read_csv(uploaded_file)
    df, diag, dropped_brands = clean_and_impute(df_raw)
    st.write("### Data Cleaning Diagnostics")
    st.write(diag)

    # Campaign input
    st.subheader("Add Campaigns")
    campaigns = []

    with st.form("campaign_form"):
        campaign_name = st.text_input("Campaign Name")
        targets = st.text_area("Target Brands (comma-separated)").split(",")
        controls_input = st.text_area("Control Brands (comma-separated)")
        controls = [c.strip() for c in controls_input.split(",") if c.strip()]
        spend = st.number_input("Campaign Spend", min_value=0, value=0)
        campaign_start = st.date_input("Campaign Start Date")
        campaign_end = st.date_input("Campaign End Date")
        measurement_start = st.date_input("Measurement Start Date")
        measurement_end = st.date_input("Measurement End Date")
        pre_period_auto = st.checkbox("Auto Pre-Period (6 months back from measurement start)", value=True)
        submitted = st.form_submit_button("Add Campaign")

        if submitted:
            campaigns.append({
                "Campaign": campaign_name,
                "Targets": [t.strip() for t in targets if t.strip()],
                "Controls": controls,
                "Spend": spend,
                "CampaignStart": pd.to_datetime(campaign_start),
                "CampaignEnd": pd.to_datetime(campaign_end),
                "MeasurementStart": pd.to_datetime(measurement_start),
                "MeasurementEnd": pd.to_datetime(measurement_end),
                "PrePeriod": "auto" if pre_period_auto else None
            })
            st.success(f"Campaign '{campaign_name}' added!")

    if st.button("Generate Reports for All Campaigns"):
        report_list = []
        for camp in campaigns:
            try:
                # Check campaign dates
                if not (camp['MeasurementStart'] <= camp['CampaignStart'] <= camp['CampaignEnd'] <= camp['MeasurementEnd']):
                    st.warning(f"Campaign '{camp['Campaign']}' period outside measurement range")

                # Pre-period
                pre_start = camp['MeasurementStart'] - pd.DateOffset(months=6) if camp['PrePeriod']=="auto" else camp['PrePeriod']

                target_dict = {}
                expected_dict = {}
                incremental_dict = {}
                lift_dict = {}
                roi_targets_dict = {}

                control_df = df[df['Brand Name'].isin(camp['Controls'])].pivot(index='Date', columns='Brand Name', values='sales_imputed').fillna(0)

                for t in camp['Targets']:
                    t_series, exp_series, ctrl_series, incr_sales, lift_pct = compute_expected_parallel(
                        df, t, camp['Controls'], pre_start, camp['MeasurementStart'], camp['MeasurementEnd']
                    )
                    target_dict[t] = t_series
                    expected_dict[t] = exp_series
                    incremental_dict[t] = incr_sales
                    lift_dict[t] = lift_pct
                    roi_targets_dict[t] = compute_roi(incr_sales, camp['Spend'])

                roi_total = compute_roi(sum(incremental_dict.values()), camp['Spend'])

                save_html_report(camp['Campaign'], target_dict, expected_dict, control_df, incremental_dict, lift_dict, roi_targets_dict, roi_total, camp['CampaignStart'], camp['CampaignEnd'])

                report_list.append({
                    'Campaign': camp['Campaign'],
                    'CampaignPeriod': f"{camp['CampaignStart'].date()} to {camp['CampaignEnd'].date()}",
                    'MeasurementPeriod': f"{camp['MeasurementStart'].date()} to {camp['MeasurementEnd'].date()}",
                    'Targets': ';'.join(camp['Targets']),
                    'Controls': ';'.join(camp['Controls']),
                    'IncrementalSales': sum(incremental_dict.values()),
                    'LiftPct': np.mean(list(lift_dict.values())),
                    'ROI': roi_total
                })

                st.success(f"Report for {camp['Campaign']} generated!")
            except Exception as e:
                st.error(f"Campaign '{camp['Campaign']}' skipped: {str(e)}")

        if report_list:
            report_df = pd.DataFrame(report_list)
            report_df.to_csv("all_campaigns_summary.csv", index=False)
            st.download_button("Download combined CSV", report_df.to_csv(index=False).encode('utf-8'), "all_campaigns_summary.csv")